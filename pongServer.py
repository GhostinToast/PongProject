# =================================================================================================
# Contributing Authors:	    Alexander Wise, Ruby Harris and Michaela Winfree
# Email Addresses:          Alex.Wise@uky.edu, Ruby.Harris@uky.edu, Michaela.Winfree@uky.edu
# Date:                     11/17/2023
# Purpose:                  This is the server file for the game of pong. It creates a server and 
#                               updates client game instances through sockets and threads.
# Misc:                     To test this program on a single machine:
#                               1. Open an instance of VS Code and open pongServer.py in it.
#                               2. Open another instance of VS Code and open the PongProject folder
#                                       in it.
#                               3. Open the pongClient.py from the Explorer in the instance of VS 
#                                       Code from step 2.
#                               4. Click the run button for the pongServer.py file.
#                               5. Click the run button for the pongClient.py file.
#                               6. Open a new terminal in the instance of VS Code from step 2.
#                               7. Copy and paste the run command from the Python terminal
#                                       generated by step 5 to the terminal from step 6.
#                               8. Finally, use the values given by HOST and PORT below
#                                       for the Server IP and Server Port, and enjoy. - Alex 
# =================================================================================================



import socket
import threading
# used to encode to strings for the sending to and from server
import json
from socket_wrapper import sock_wrapper
# Constants
# IP of the host of the server. 
# Ensure that the IP is the same as the pongClient.py.
HOST = 'localhost'#'192.168.159.1'
# Port # of the server. Set > 1023 for non-priveleged ports. 
# Ensure that the # is the same as the pointClient.py.
PORT = 6000

# Use this file to write your server logic
# You will need to support at least two clients


# This class holds the most current information about the game status
class gameSave:
    def __init__(self):

        # ball movement and relevant locks
        self.ball_lock = threading.Lock()       # ball movement thread locker
        self.ballx = 0 # X, Y                   # ball positions
        self.bally = 0

        # score tracker info
        self.score_lock = threading.Lock()    
        self.score = [0,0] # lScore, rScore

        # right paddle
        self.rPaddle_lock = threading.Lock()
        self.rPaddlex = 0 # X, Y, Moving
        self.rPaddley = 0
        self.rPaddlemov = ""

        # left paddle
        self.lPaddle_lock = threading.Lock()
        self.lPaddlex = 0 # X, Y, Moving
        self.lPaddley = 0
        self.lPaddlemov = ""

        # sync (the sync from the clients)
        self.sync_lock = threading.Lock()
        self.sync = 0 # The most recent sync # we saw

        # left player ready to play (connected & communicating)
        self.lReady_lock = threading.Lock()
        self.lReady = False # Is the left player ready to start?

        # right player ready to play
        self.rReady_lock = threading.Lock()
        self.rReady = False # is the right player ready to start?

        # data frame; the information we'll send to the clients each outgoing update
        self.df_lock = threading.Lock()
        self.dataf = {

                    # Essentially the seq # for the frame
                    'seq': self.sync,

                    # left paddle's x and y positions
                    'lPaddlex': self.lPaddlex,
                    'lPaddley': self.lPaddley,
                    'lPaddlemov' : self.lPaddlemov,
                
                    # right paddle's x and y positions
                    'rPaddlex': self.rPaddlex,
                    'rPaddley': self.rPaddley,
                    'rPaddlemov': self.rPaddlemov,

                    # Ball's x and y positions
                    'ballx': self.ballx,
                    'bally': self.bally,

                    # Scores
                    'score': self.score
                    }



def clientControl(shutDown, game, clientSocket, clientNumber):
    Connection = sock_wrapper(clientSocket)         # see socket_wrapper.py; we use a wrapper to handle ...
       # a lot of the details of the connection, such as error handling

    while not shutDown.is_set() and not Connection.closed:
        # Try to receive data from the client
        try:
            _ , newMessage = Connection.recv() 

            # Close server on empty data.
            if not newMessage:
                print(f"Client {clientNumber} disconnected unexpectedly.")
                shutDown.set()  # Set the shutdown flag
                Connection.close()  # Close the client socket
                break

            # if we get a start message, 
            if newMessage['type'] == 'start':
                if clientNumber == 0:
                    # mark this player as ready to go
                    with game.lReady_lock:
                        game.lReady = True

                    # and add the side that this player will control to the message
                    newMessage['playerpaddle'] = 'left'

                elif clientNumber == 1:
                    with game.rReady_lock:
                        game.rReady = True
                    newMessage['playerpaddle'] = 'right'

                # if both sides are ready to play, (note the use of locks to check)
                with game.lReady_lock, game.rReady_lock:
                    # add the info that we're ready for data to the message
                    if game.lReady and game.rReady:
                        newMessage['data'] = True
                    else:
                        newMessage['data'] = False
                    # and send out the message
                    Connection.send(newMessage)
                continue

            # if we get a gimme message (aka the client requests info)
            if newMessage['type'] == 'gimme':
                print(game.dataf)
                # give the info! :D
                Connection.send(game.dataf)
                continue
            
            # if we get an update from the client
            elif newMessage['type'] == 'update':

                # lock the gamesync so we can check it...
                game.sync_lock.acquire() 
                # if the update is newer than what we currently have, 
                if game.dataf['seq'] < newMessage['data']['seq']:    
                    # update our sequence #, and the unlock the seq# lock   
                    game.dataf['seq'] = newMessage['data']['seq']
                    game.sync_lock.release()

                    # grab the ball data from the update
                    with game.ball_lock:
                        game.dataf['ballx'] = newMessage['data']['ballx']
                        game.dataf['bally'] = newMessage['data']['bally']

                    # grab the score from the incoming update
                    with game.score_lock:
                        game.dataf['score'] = newMessage['data']['score']
                    
                    # then grab only the paddle data from the relevant side
                    if clientNumber == 0:
                        with game.lPaddle_lock:
                            game.dataf['lPaddlex'] = newMessage['data']['playerpaddlex']
                            game.dataf['lPaddley'] = newMessage['data']['playerpaddley']
                            game.dataf['lPaddlemov'] = newMessage['data']['playermov']
                    elif clientNumber == 1:
                        with game.rPaddle_lock:
                            game.dataf['rPaddlex'] = newMessage['data']['playerpaddlex']
                            game.dataf['rPaddley'] = newMessage['data']['playerpaddley']
                            game.dataf['rPaddlemov'] = newMessage['data']['playermov']

                    # keep us updated ￣へ￣
                    print("update received")
                else:
                    game.sync_lock.release()
                    if clientNumber == 0:
                        with game.lPaddle_lock:
                            game.dataf['lPaddlex'] = newMessage['data']['playerpaddlex']
                            game.dataf['lPaddley'] = newMessage['data']['playerpaddley']
                            game.dataf['lPaddlemov'] = newMessage['data']['playermov']
                    elif clientNumber == 1:
                        with game.rPaddle_lock:
                            game.dataf['rPaddlex'] = newMessage['data']['playerpaddlex']
                            game.dataf['rPaddley'] = newMessage['data']['playerpaddley']
                            game.dataf['rPaddlemov'] = newMessage['data']['playermov']
                continue
            
            # if we get a message we weren't expecting, ಠ╭╮ಠ
            else:
                print(f"Unknown message type: {newMessage['type']}")

        # if we got a connection error, even more  ಠ╭╮ಠ. perhaps even ಥ_ಥ   
        except Connection.holder.error:
            # but thats okey cause this isn't the marines and giving up is an option!
            print(f"Server will close.")
    



def main():
    print('Server Online')

    # Create our server type 1 socket
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Bind the server socket to the HOST and PORT
    server.bind((HOST, PORT))

    # List of client threads
    clientThreads = []

    # Event to shutdown the server
    endServer = threading.Event()

    # listen for new clients
    server.listen()
    # set up our main game info spot
    gameState = gameSave()


    clientNum = 0       # used to track which client is connecting
    maxClient = 2       # self-explanatory


    while not endServer.is_set() and clientNum < maxClient:
        # Accept a connection from a client
        newClient, retAddress = server.accept()
        # (～￣▽￣)～ "Got one!"
        print('Client ' + str(retAddress) + ' connected.')

        # Create a new thread for each client
        newThread = threading.Thread(target=clientControl, args=(endServer, gameState, newClient, clientNum))
        newThread.start()
        clientThreads.append(newThread)  # Store the thread reference in the list
        clientNum += 1

    server.close()

    # Join all client threads for proper termination
    for client in clientThreads:
        client.join()

    print('Server Closing')

if __name__ == "__main__": 
    main()